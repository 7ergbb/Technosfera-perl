package Local::App::GenCalc;

use strict;

my $file_path = '/tmp/calcs.txt';

sub new_one {
    # Функция вызывается по таймеру каждые 100
    my $new_row = join $/, rand(5).' + '.rand(5), 
                  rand(2).' + '.rand(5).' * '.rand(10), 
                  '('.rand(10).' + '.rand(8).') * '.rand(7), 
                  rand(5).' + '.rand(6).' * '.rand(8).' ^ '.rand(12), 
                  rand(20).' + '.rand(40).' * '.rand(45).' ^ '.rand(12), 
                  (rand(12)/(rand(17)+1)).' * ('.(rand(14)/(rand(30)+1)).' - '.rand(10).') / '.rand(10).'.0 ^ 0.'.rand(6),  
                  rand(8).' + 0.'.rand(10), 
                  rand(10).' + .5',
                  rand(10).' + .5e0',
                  rand(10).' + .5e1',
                  rand(10).' + .5e+1', 
                  rand(10).' + .5e-1', 
                  rand(10).' + .5e+1 * 2';
    # Далее происходить запись в файл очередь
    ...
    return;
}

#Определение обрабатываемых сигналов
$SIG{...} = \&...;

sub start_server {
    # На вход приходит номер порта который будет слушат сервер для обработки запросов на получение данных
    my $port = shift;
    # Создание сервера и обработка входящих соединений, форки не нужны 
    # Входящее сообщение это 2-х байтовый инт (кол-во сообщений которое надо отдать в ответ)
    # Исходящее сообщение: ROWS_CNT ROW; ROW := ROW [ROW]; ROW := LEN MESS; LEN - 4-х байтовый инт; MESS - сообщение указанной длины
}

sub get {
    # На вход получаем кол-во запрашиваемых сообщений
    my $limit = shift;

    # Открытие файла, чтение N записей
    # Надо предусмотреть, что файла может не быть, а так же в файле может быть меньше сообщений чем запрошено
    my $ret = []; # Возвращаем ссылку на массив строк

    return $ret;
}

1;
